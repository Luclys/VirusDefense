<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>VirusDefense</title>
    <script src="https://cdn.babylonjs.com/babylon.max.js"></script>
    <script src="../src/HexGridCreator.js"></script>

    <!--TODO : Add an icon to the tab-->

    <style>
        #render_canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<canvas id="render_canvas"></canvas>
<script>
    // For Webstorm live coding, the script is temporally inside the .html
    // Once finished, it will be moved to the appropriates js source files.
    var rotateFactor = 0;
    window.addEventListener('DOMContentLoaded', function () {
        var canvas = document.getElementById('render_canvas');
        var engine = new BABYLON.Engine(canvas, true);

        var createScene = function () {
            let gridSize = 10;
            let hexHeightSize = 3;
            let hexLength = 7;
            let hexSpacing = 0.5;
            // Not actually Spacing... more like reducing the size to make the illusion it is separated. My math aren't good enough.
            let hexWidthDistance = (Math.sqrt(3) * hexLength);
            let hexHeightDistance = (2 * hexLength);
            let rowLengthAddition = 0;


            // SCENE
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(1, 0.2, 0.2, 1)

            // LIGHT
            var light = new BABYLON.PointLight("light", new BABYLON.Vector3(30, 30, 30), scene);

            // GRAVITY
            scene.gravity = new BABYLON.Vector3(0, -9.81, 0);

            // CAMERA
            //var camera = new BABYLON.ArcRotateCamera("arcCam", BABYLON.Tools.ToRadians(45), BABYLON.Tools.ToRadians(45), 50.0, box.position,scene);
            //var camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(10,10,-10), scene);
            var camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(10, 10, -10), scene)

            // Enable Collisions
            camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);
            scene.collisionsEnabled = true;
            camera.checkCollisions = true;

            // Custom Controls
            camera.attachControl(scene, true);
            camera.keysUp.push(90);    // Z
            camera.keysLeft.push(81);  // Q
            camera.keysDown.push(83);  // S
            camera.keysRight.push(68); // D
            camera.keysUpward.push(32) // SpaceBar
            camera.keysDownward.push(17) // Ctrl


            // MATERIALS
            var towerLevel1 = new BABYLON.StandardMaterial("material", scene);
            towerLevel1.emissiveColor = new BABYLON.Color3(0.9, 0.4, 0.9);

            var towerLevel2 = new BABYLON.StandardMaterial("material", scene);
            towerLevel2.emissiveColor = new BABYLON.Color3(0.2, 0.4, 0.9);

            var testMaterial = new BABYLON.StandardMaterial("material", scene);
            testMaterial.emissiveColor = new BABYLON.Color3(0.9, 0.4, 0.3);

            // CONSTRUCTIONS
            //create the hex grid
            createHexGrid(gridSize, hexHeightSize, hexWidthDistance, hexHeightDistance, rowLengthAddition, hexSpacing, scene);

            let firstHexaMesh = scene.getMeshByName("hexTile00");
            firstHexaMesh.material = testMaterial;
            let middleHexaMesh = scene.getMeshByName("hexTile" + (gridSize - 1) + (gridSize - 1));
            middleHexaMesh.material = testMaterial;


            //handling of hex tile picking
            scene.onPointerDown = function (event, pickResult) {
                let pickedMesh = pickResult.pickedMesh
                // If a Mesh is picked with Left clic (main button)
                // 1 -> Middle Clic, 2 -> right Clic
                if (pickedMesh && event.button === 0) {
                    console.log("You picked the " + pickedMesh.name + " it has the state : " + pickedMesh.state);
                    switch (pickedMesh.state) {
                        case "Buildable" :
                            var turret = BABYLON.MeshBuilder.CreateCylinder("turretLv1On" + pickedMesh.name, {
                                height: hexHeightSize * 3,
                                diameter: (hexHeightDistance - hexSpacing) * 0.20,
                                tessellation: 6,
                                updatable: true
                            }, scene)

                            turret.position.copyFrom(pickedMesh.position);
                            turret.material = towerLevel1;


                            pickedMesh.state = "TurretLv1";
                            console.log("Building a Level 1 turret on top of " + pickedMesh.name)
                            break;
                        case "TurretLv1" :
                            let turretLv1 = scene.getMeshByName("turretLv1On" + pickedMesh.name);
                            turretLv1.name = "turretLv2On" + pickedMesh.name;
                            turretLv1.material = towerLevel2;
                            turretLv1.position.y += hexHeightSize;


                            pickedMesh.state = "TurretLv2";
                            console.log("Building a Level 2 turret on top of " + pickedMesh.name)
                            break;
                        case "TurretLv2" :
                            console.log("You can't upgrade this turret")
                    }

                }
            };

            return scene;
        };


        let scene = createScene();
        engine.runRenderLoop(function () {
            scene.render();
        });
    });

</script>
</body>
</html>